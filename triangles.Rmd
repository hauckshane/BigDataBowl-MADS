---
title: "Triangles"
author: "Shane Hauck, Marion Haney, Devin Basley, Vinay Maruri"
date: "2023-12-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(progress)
library(tidyverse)
library(gganimate)
theme_set(theme_bw())

library(sportyR)
field_params <- list(
  field_apron = "springgreen3",
  field_border = "springgreen3",
  offensive_endzone = "springgreen3",
  defensive_endzone = "springgreen3",
  offensive_half = "springgreen3",
  defensive_half = "springgreen3"
)

nfl_field <- function(xlims) {
  geom_football(
    league = "nfl",
    display_range = "full",
    x_trans = 60,
    y_trans = 26.6667,
    xlims = xlims,
    color_updates = field_params
  )
}
```


# Reading in the cleaned data: just inside zone run plays
## USE WK2_SameDirection_TrackData for analysis of week 2

```{r}
wk2_track_data <- read.csv("data/WK2_SameDirection_TrackData.csv")
```

Make gamePlayId which is a combination of gameId and playId. This helps us 
identify each unique play.
```{r}
wk2_track_data$gamePlayId <- paste(wk2_track_data$gameId, wk2_track_data$playId)
```

# FINDING POINTS OF THE TRIANGLE

We want to identify 3 points of the triangle which represents the ballCarrier's
path: start, end, and furthest.

Save these coordinates in the data. Then, we can calculate the angle of change.

## Start
(X,Y) of ballCarrier when event == “handoff”

start_x, start_y, start_frameId

```{r}
start <- wk2_track_data %>%
  filter(nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  filter(event == "handoff") %>%
  reframe(
    start_x = x,
    start_y = y,
    start_frameId = frameId,
    gamePlayId = gamePlayId
  )

wk2_track_data <- merge(wk2_track_data, start, by = "gamePlayId")
```

## End
If: event includes “tackle”, (X,Y) of ballCarrier when event == “tackle”
Else: location where ballCarrier breaks gap point
Shane’s soccer code: checks every player pairing and sees if ballCarrier line 
crosses in-between lines

Do when the player breaks gap point first, because they could be tackled 
after that. Then, if end_x and end_y are NA for that play, check those plays 
for the tackle events.

end_x, end_y, end_frameId


```{r}
# Breaks the gap point
# Create Variables to get ball Carriers X and Y coordinates
wk2_track_data <- wk2_track_data %>%
  group_by(gamePlayId) %>%
  mutate(
    ballCarrierX = ifelse(nflId == ballCarrierId, x, NA),
    ballCarrierY = ifelse(nflId == ballCarrierId, y, NA)
  ) %>%
  fill(ballCarrierX, .direction = c("updown")) %>%
  fill(ballCarrierY, .direction = c("updown"))


# Function to check if two line segments intersect
is_line_segment_intersect <- function(x1, y1, x2, y2, x3, y3, x4, y4) {
  # Calculate the slope and intercept for both line segments
  # Handling vertical lines separately
  vertical1 <- x1 == x2
  vertical2 <- x3 == x4

  if (vertical1 && vertical2) {
    # Both lines are vertical - check if they are the same line and have overlapping y-ranges
    return(x1 == x3 && min(y1, y2) <= max(y3, y4) && max(y1, y2) >= min(y3, y4))
  } else if (vertical1 || vertical2) {
    # One line is vertical - calculate intersection with the other line
    if (vertical1) {
      y_intersect <- (y3 - y4) / (x3 - x4) * (x1 - x3) + y3
      return(y_intersect >= min(y1, y2) && y_intersect <= max(y1, y2) && x1 >= min(x3, x4) && x1 <= max(x3, x4))
    } else {
      y_intersect <- (y1 - y2) / (x1 - x2) * (x3 - x1) + y1
      return(y_intersect >= min(y3, y4) && y_intersect <= max(y3, y4) && x3 >= min(x1, x2) && x3 <= max(x1, x2))
    }
  } else {
    # Both lines are non-vertical - use the formula for intersection
    slope1 <- (y2 - y1) / (x2 - x1)
    intercept1 <- y1 - slope1 * x1
    slope2 <- (y4 - y3) / (x4 - x3)
    intercept2 <- y3 - slope2 * x3

    # Check if lines are parallel
    if (slope1 == slope2) {
      return(intercept1 == intercept2 && min(x1, x2) <= max(x3, x4) && max(x1, x2) >= min(x3, x4))
    } else {
      x_intersect <- (intercept2 - intercept1) / (slope1 - slope2)
      return(x_intersect >= min(x1, x2) && x_intersect <= max(x1, x2) && x_intersect >= min(x3, x4) && x_intersect <= max(x3, x4))
    }
  }
}

# Function to check if ball carrier splits the gap
check_intersection <- function(ballCarrierStartX, ballCarrierStartY, ballCarrierEndX, ballCarrierEndY, players_df) {
  player_pairs <- combn(nrow(players_df), 2, simplify = FALSE)

  any(sapply(player_pairs, function(pair) {
    player1 <- players_df[pair[1], ]
    player2 <- players_df[pair[2], ]
    is_line_segment_intersect(ballCarrierStartX, ballCarrierStartY, ballCarrierEndX, ballCarrierEndY, player1$x, player1$y, player2$x, player2$y)
  }))
}




# Calculate total number of groups for progress bar
total_groups <- wk2_track_data %>%
  filter(position %in% c("T", "G", "C") | nflId == ballCarrierId) %>%
  count(gamePlayId, frameId) %>%
  ungroup() %>% 
  summarise(total = sum(n)) %>%
  pull(total)

# Initialize progress bar
pb <-  progress_bar$new(total = total_groups, format = " Processing [:bar] :percent :elapsed")

splitGap <- wk2_track_data %>%
  filter(position %in% c("T", "G", "C") | nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  arrange(frameId) %>%
  do({
    pb$tick() # Update progress bar
    with(., {
      # For each frame, find the ball carrier's position 1 frames before
      ball_carrier_positions <- filter(., nflId == ballCarrierId)
      if (nrow(ball_carrier_positions) > 2) {
        split_gap <- FALSE
        for (i in 2:nrow(ball_carrier_positions)) {
          # Ball carrier's start and end position for the line segment
          start_pos <- ball_carrier_positions[i - 1, ]
          end_pos <- ball_carrier_positions[i, ]
          # Get positions of other players
          other_players <- filter(., nflId != ballCarrierId & frameId == ball_carrier_positions$frameId[i])
          # Check for intersection
          if (nrow(other_players) > 1) {
            split_gap <- split_gap | check_intersection(start_pos$x, start_pos$y, end_pos$x, end_pos$y, other_players)
          }
        }
        return(data.frame(split_gap = split_gap))
      } else {
        return(data.frame(split_gap = FALSE))
      }
    })
  }) %>%
  ungroup() %>%
  group_by(gamePlayId) %>%
  summarise(split_gap = any(split_gap), .groups = "drop")
```

```{r}
# Just the tackles
end_tackles <- wk2_track_data %>%
  filter(nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  filter(event == "tackle") %>%
  reframe(
    end_x = x,
    end_y = y,
    end_frameId = frameId,
    gamePlayId = gamePlayId
  )
```

```{r}
# Merge back to the data
# TODO
wk2_track_data <- merge(wk2_track_data, end_tackles, by = "gamePlayId")
```


## Furthest
Between start_frameID and end_frameID, take max of the absolute value of:
1. Start Y - max Y
2. Start Y - min Y

furthest_x, furthest_y, furthest_frameId

```{r}
# Figure out furthest y coordinate (max of either direction)
furthest_y <- wk2_track_data %>%
  group_by(gamePlayId) %>%
  filter(nflId == ballCarrierId) %>%
  filter(frameId > start_frameId) %>%
  filter(frameId < end_frameId) %>%
  reframe(
    max_y = max(y),
    min_y = min(y),
    start_y = start_y,
    abs_max_y = abs(start_y - max_y),
    abs_min_y = abs(start_y - min_y),
    furthest_y = ifelse(abs_max_y >= abs_min_y, max_y, min_y),
    x = x,
    y = y,
    frameId = frameId
  )
```

```{r}
# Grab the x coordinate and frame id where we see furthest_y
furthest <- furthest_y %>%
  group_by(gamePlayId) %>%
  filter(y == furthest_y) %>%
  reframe(
    furthest_x = x,
    furthest_y = y,
    furthest_frameId = frameId,
    gamePlayId = gamePlayId
  )
```

```{r}
# Merge back to the data
wk2_track_data <- merge(wk2_track_data, furthest, by = "gamePlayId")
```



# Find angle of change
The angle we want is the inside angle at the furthest point.
If we have vertices F, S, and E (furthest, start, end) we want angle F, 
which is made from line segments EF and FS.

1. angle FSE = arctan((end_y - furthest_y)/ (end_x - furthest_y))
2. angle F = 180 - angle FSE

Radians to degree conversion: degree = radians * (180/pi)

```{r}
# Function to calculate the angle of change, angle F
find.angle.f <- function(x_s, y_s, x_e, y_e, x_f, y_f) {
  # Convert input values to numeric
  x_s <- as.numeric(x_s)
  y_s <- as.numeric(y_s)
  x_e <- as.numeric(x_e)
  y_e <- as.numeric(y_e)
  x_f <- as.numeric(x_f)
  y_f <- as.numeric(y_f)

  # Calculate the angle FSE in radians
  fse_rad <- atan2(y_e - y_f, x_e - x_f)

  # Convert the angle from radians to degrees
  fse_deg <- fse_rad * (180 / pi)

  # Calculate the angle at vertex F (angle EF and FS)
  f_deg <- 180 - fse_deg

  return(f_deg)
}
```

```{r}
# Apply the function that calculates the angle to the data
wk2_track_data$angle <- apply(wk2_track_data, 1, function(row) {
  if (all(complete.cases(row[c(
    "start_x", "start_y",
    "end_x", "end_y",
    "furthest_x", "furthest_y"
  )]))) {
    find.angle.f(
      row[["start_x"]], row[["start_y"]],
      row[["end_x"]], row[["end_y"]],
      row[["furthest_x"]], row[["furthest_y"]]
    )
  } else {
    NA
  }
})
```


# Save the data
Saving the data as wk2_triangles.csv

```{r}
# Save dataframe as CSV
write.csv(wk2_track_data, file = "data/wk2_triangles.csv", row.names = FALSE)
```
