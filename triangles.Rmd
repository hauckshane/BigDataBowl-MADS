---
title: "Triangles"
author: "Shane Hauck, Marion Haney, Devin Basley, Vinay Maruri"
date: "2023-12-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(progress)
library(tidyverse)
library(gganimate)
theme_set(theme_bw())

library(sportyR)
field_params <- list(
  field_apron = "springgreen3",
  field_border = "springgreen3",
  offensive_endzone = "springgreen3",
  defensive_endzone = "springgreen3",
  offensive_half = "springgreen3",
  defensive_half = "springgreen3"
)

nfl_field <- function(xlims) {
  geom_football(
    league = "nfl",
    display_range = "full",
    x_trans = 60,
    y_trans = 26.6667,
    xlims = xlims,
    color_updates = field_params
  )
}
```


# Reading in the cleaned data: just inside zone run plays
## USE WK2_SameDirection_TrackData for analysis of week 2

```{r}
wk2_track_data <- read.csv("data/WK2_SameDirection_TrackData.csv")
```

Make gamePlayId which is a combination of gameId and playId. This helps us 
identify each unique play.
```{r}
wk2_track_data$gamePlayId <- paste(wk2_track_data$gameId, wk2_track_data$playId)
```

# FINDING POINTS OF THE TRIANGLE

We want to identify 3 points of the triangle which represents the ballCarrier's
path: start, end, and furthest.

Save these coordinates in the data. Then, we can calculate the angle of change.

## Start
(X,Y) of ballCarrier when event == “handoff”

start_x, start_y, start_frameId

```{r}
start <- wk2_track_data %>%
  filter(nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  filter(event == "handoff") %>%
  reframe(
    start_x = x,
    start_y = y,
    start_frameId = frameId,
    gamePlayId = gamePlayId
  )

wk2_track_data <- merge(wk2_track_data, start, by = "gamePlayId")
```

## End
If: event includes “tackle”, (X,Y) of ballCarrier when event == “tackle”
Else: location where ballCarrier breaks gap point
Shane’s soccer code: checks every player pairing and sees if ballCarrier line 
crosses in-between lines

Do when the player breaks gap point first, because they could be tackled 
after that. Then, if end_x and end_y are NA for that play, check those plays 
for the tackle events.

end_x, end_y, end_frameId


```{r}
# Breaks the gap point
# Create Variables to get ball Carriers X and Y coordinates
wk2_track_data <- wk2_track_data %>%
  group_by(gamePlayId) %>%
  mutate(
    ballCarrierX = ifelse(nflId == ballCarrierId, x, NA),
    ballCarrierY = ifelse(nflId == ballCarrierId, y, NA)
  ) %>%
  fill(ballCarrierX, .direction = c("updown")) %>%
  fill(ballCarrierY, .direction = c("updown"))


# Function to check intersection between two line segments
# Returns a list with the intersection status and point coordinates
is_line_segment_intersect <- function(x1, y1, x2, y2, x3, y3, x4, y4) {
  # Handle cases of vertical line segments
  vertical1 <- x1 == x2
  vertical2 <- x3 == x4
  # [Additional logic for vertical lines can be added here]

  # For non-vertical lines, calculate intersection point
  if (!vertical1 && !vertical2) {
    slope1 <- (y2 - y1) / (x2 - x1)
    intercept1 <- y1 - slope1 * x1
    slope2 <- (y4 - y3) / (x4 - x3)
    intercept2 <- y3 - slope2 * x3

    # Check if non-parallel lines intersect
    if (slope1 != slope2) {
      x_intersect <- (intercept2 - intercept1) / (slope1 - slope2)
      y_intersect <- slope1 * x_intersect + intercept1

      # Ensure intersection point lies within both line segments
      if (x_intersect >= min(x1, x2) && x_intersect <= max(x1, x2) &&
        x_intersect >= min(x3, x4) && x_intersect <= max(x3, x4)) {
        return(list(intersect = TRUE, x = x_intersect, y = y_intersect))
      }
    }
  }

  # No intersection or calculation not possible
  return(list(intersect = FALSE, x = NA, y = NA))
}

# Function to determine if ball carrier splits the gap between players
# Returns intersection status, point, and frameId
check_intersection <- function(frameId, ballCarrierStartX, ballCarrierStartY, ballCarrierEndX, ballCarrierEndY, players_df) {
  # Rank players by y-coordinate for adjacency check
  players_df$rank <- rank(players_df$y)
  player_pairs <- combn(nrow(players_df), 2, simplify = FALSE)

  # Iterate through player pairs for intersection check
  for (pair in player_pairs) {
    player1 <- players_df[pair[1], ]
    player2 <- players_df[pair[2], ]

    # Check adjacency based on y-coordinate rank
    if (abs(player1$rank - player2$rank) == 1 | abs(player1$rank - player2$rank) == 2) {
      result <- is_line_segment_intersect(
        ballCarrierStartX, ballCarrierStartY, ballCarrierEndX, ballCarrierEndY,
        player1$x, player1$y, player2$x, player2$y
      )
      if (result$intersect) {
        # Return intersection details including frameId
        return(c(result, frameId = frameId))
      }
    }
  }

  # No intersection found among adjacent players
  return(list(intersect = FALSE, x = NA, y = NA, frameId = frameId))
}

# Calculate total number of groups for progress bar
total_groups <- wk2_track_data %>%
  filter(position %in% c("T", "G", "C") | nflId == ballCarrierId) %>%
  count(gamePlayId, frameId) %>%
  ungroup() %>%
  summarise(total = sum(n)) %>%
  pull(total)

# Initialize progress bar for process monitoring
pb <- progress_bar$new(total = total_groups, format = " Processing [:bar] :percent :elapsed")

# Process data to find first gap split by ball carrier
splitGap <- wk2_track_data %>%
  filter(position %in% c("T", "G", "C") | nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  arrange(frameId) %>%
  do({
    pb$tick() # Update progress bar
    with(., {
      ball_carrier_positions <- filter(., nflId == ballCarrierId)
      if (nrow(ball_carrier_positions) > 2) {
        for (i in 2:nrow(ball_carrier_positions)) {
          start_pos <- ball_carrier_positions[i - 1, ]
          end_pos <- ball_carrier_positions[i, ]
          current_frameId <- end_pos$frameId
          other_players <- filter(., nflId != ballCarrierId & frameId == current_frameId)

          # Check for intersection and return result with frameId
          if (nrow(other_players) > 1) {
            result <- check_intersection(current_frameId, start_pos$x, start_pos$y, end_pos$x, end_pos$y, other_players)
            if (result$intersect) {
              return(data.frame(split_gap = TRUE, x_intersect = result$x, y_intersect = result$y, frameId = result$frameId))
            }
          }
        }
        return(data.frame(split_gap = FALSE, x_intersect = NA, y_intersect = NA, frameId = NA))
      } else {
        return(data.frame(split_gap = FALSE, x_intersect = NA, y_intersect = NA, frameId = NA))
      }
    })
  }) %>%
  ungroup() %>%
  # Summarize results across gamePlayIds
  group_by(gamePlayId) %>%
  summarise(split_gap = any(split_gap), x_intersect = first(x_intersect), y_intersect = first(y_intersect), frameId_intersect = first(frameId), .groups = "drop")
```

```{r}
wk2_track_data <- merge(wk2_track_data, splitGap, by = "gamePlayId")
```


```{r}
# Just the first of tackle, first_contact, touchdown, or out of bounds that occurs
triangle_end_point <- wk2_track_data %>%
  filter(nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  filter(event %in% c("tackle", "first_contact", "touchdown", "out_of_bounds") |
    frameId == frameId_intersect) %>%
  filter(frameId == min(frameId)) %>%
  reframe(
    end_x = x,
    end_y = y,
    end_frameId = frameId,
    gamePlayId = gamePlayId
  )
```


```{r}
# Merge back to the data
wk2_track_data <- merge(wk2_track_data, triangle_end_point, by = "gamePlayId")
```



# Find angle of change
The angle we want is the inside angle at the furthest point.
If we have vertices F, S, and E (furthest, start, end) we want angle F, 
which is made from line segments EF and FS.

1. angle FSE = arctan((end_y - furthest_y)/ (end_x - furthest_y))
2. angle F = 180 - angle FSE

Radians to degree conversion: degree = radians * (180/pi)

```{r}
# Function to calculate the angle of change, angle F
find.angle.f <- function(x_s, y_s, x_e, y_e, x_f, y_f) {
  # Convert input values to numeric
  x_s <- as.numeric(x_s)
  y_s <- as.numeric(y_s)
  x_e <- as.numeric(x_e)
  y_e <- as.numeric(y_e)
  x_f <- as.numeric(x_f)
  y_f <- as.numeric(y_f)

  # Calculate vectors FS and FE
  fs_x <- x_s - x_f
  fs_y <- y_s - y_f
  fe_x <- x_e - x_f
  fe_y <- y_e - y_f

  # Calculate the angle between vectors FS and FE in radians
  dot_product <- fs_x * fe_x + fs_y * fe_y
  magnitude_fs <- sqrt(fs_x^2 + fs_y^2)
  magnitude_fe <- sqrt(fe_x^2 + fe_y^2)
  angle_rad <- acos(dot_product / (magnitude_fs * magnitude_fe))

  # Convert the angle from radians to degrees
  angle_deg <- angle_rad * (180 / pi)

  # Normalize the angle to the range [0, 360)
  angle_deg_normalized <- 180 - (angle_deg) %% 360

  return(angle_deg_normalized)
}

```

```{r}
# Function that calculates the smallest difference between two angles, correctly handling the wrap-around at 360 degrees.
smallest_angle_diff <- function(angle1, angle2) {
  diff <- abs(angle1 - angle2)
  ifelse(diff > 180, 360 - diff, diff)
}
```


# Finding the greatest change in direction

```{r}
angls <- wk2_track_data %>%
  filter(frameId >= start_frameId & frameId <= end_frameId) %>%
  filter(nflId == ballCarrierId) %>%
  group_by(gamePlayId) %>%
  arrange(gamePlayId, frameId) %>%
  reframe(gamePlayId, frameId,
    # Calculate the angle using the find.angle.f function
    angle = find.angle.f(lag(x, 1, default = NA), lag(y, 1, default = NA), 
                         lead(x, 1, default = NA), lead(y, 1, default = NA), 
                         x, y),

    # Calculate the absolute change in angle between frames
    angle_change = abs(angle - lag(angle, 1, default = NA)),

    # Calculate the absolute change in orientation between frames
    orientation_change = smallest_angle_diff(o, lag(o, 1, default = NA)),

    # Create a composite measure of change
    total_change = angle_change + orientation_change,
    
    # Angle adjusting for cutbacks or bounces (greater than 0 bounce, 360 or less cutback)
    relative_angle = ifelse((playSide == "left" & lead(y, 1, default = NA) < y) |
                              (playSide == "right" & lead(y, 1, default = NA) > y), (0 - angle) %% 360, angle)
  ) %>%
  ungroup() %>% na.omit() %>%
  # Deal with extremely large orientation changes
  # If orientation change huge, just use angle change
  # Calculate the 99th percentile of angle_change
  mutate(orientation_change_99th = quantile(orientation_change, 0.99, na.rm = TRUE)) %>%
  mutate(
    total_change = ifelse(orientation_change > orientation_change_99th, angle_change + orientation_change_99th, total_change)
  ) %>%
  select(-orientation_change_99th)

# correlation of angle change and orientation change
angls %>% select(angle_change, orientation_change) %>% cor()

# Find the frame with the greatest change in direction and the corresponding angle
max_angle_change <- angls %>%
  group_by(gamePlayId) %>%
  filter(total_change == max(total_change, na.rm = TRUE)) %>%
  mutate(
    angle_change_at_max_change = angle_change,
    orientation_change_at_max_change = orientation_change,
    total_change_at_max_change = total_change,
    angle_at_max_change = first(angle),
    relative_angle_at_max_change = first(relative_angle),
    frameId_at_max_change = first(frameId)
  ) %>%
  distinct(gamePlayId, frameId_at_max_change, angle_change_at_max_change, orientation_change_at_max_change, total_change_at_max_change, total_change_at_max_change, angle_at_max_change, relative_angle_at_max_change)

max_angle_change %>% ungroup() %>% select(angle_change_at_max_change, orientation_change_at_max_change) %>% cor()
```

```{r}
wk2_track_data <- full_join(wk2_track_data, angls, by = c("gamePlayId", "frameId"))
wk2_track_data <- full_join(wk2_track_data, max_angle_change, by = "gamePlayId")
```


```{r}
ggplot(max_angle_change, aes(x = total_change_at_max_change)) +
  geom_histogram() 

ggplot(wk2_track_data %>% distinct(gamePlayId, total_change_at_max_change, expectedPointsAdded), aes(x = total_change_at_max_change, y = expectedPointsAdded)) +
  geom_point(alpha = 0.5) +
  geom_smooth()

ggplot(wk2_track_data %>% distinct(gamePlayId, start_frameId, frameId_at_max_change, playSide, expectedPointsAdded), aes(x = frameId_at_max_change - start_frameId, y = expectedPointsAdded)) +
  geom_point() +
  facet_wrap(~playSide) +
  geom_smooth()
```



# Where the greates change in direction occurs calculate that angle with the end point

```{r}
full_angle <- wk2_track_data %>%
  filter(nflId == ballCarrierId) %>%
  filter(frameId == frameId_at_max_change) %>%
  mutate(
    angle_greatestChange = find.angle.f(start_x, start_y, end_x, end_y, x, y)
  )
```

```{r}
ggplot(full_angle, aes(x = angle_greatestChange)) +
  geom_histogram() +
  facet_wrap(~playSide) +
  geom_vline(xintercept = 180, linetype = "dashed")

ggplot(full_angle, aes(x = angle_at_max_change, y = expectedPointsAdded)) +
  geom_point() +
  facet_wrap(~playSide) +
  geom_smooth() +
  geom_vline(xintercept = 180, linetype = "dashed")

ggplot(full_angle %>% filter(expectedPointsAdded != min(expectedPointsAdded)), aes(x = frameId_at_max_change - start_frameId)) +
  geom_histogram() +
  facet_wrap(~playSide)
```

```{r}
wk2_track_data <- merge(wk2_track_data, full_angle %>% select(gamePlayId, angle_greatestChange), by = "gamePlayId")
```



# Edge Intensity Rating


```{r}



ballcarrier <- wk2_track_data %>%
  group_by(gamePlayId, frameId) %>%
  filter(frameId > start_frameId & frameId < end_frameId) %>%
  filter(nflId == ballCarrierId) %>%
  mutate(
    ballCarrier_x = x,
    ballCarrier_y = y,
    ballCarrier_s = s,
    ballCarrier_a = a,
    ballCarrier_o = o
  ) %>%
  select(
    gamePlayId, frameId, ballCarrier_x, ballCarrier_y,
    ballCarrier_s, ballCarrier_a, ballCarrier_o
  )

wk2_track_data <- full_join(wk2_track_data, ballcarrier, by = c("gamePlayId", "frameId"))

edgedefenders <- wk2_track_data %>%
  group_by(gamePlayId, frameId) %>%
  filter(
    club != possessionTeam,
    club != "football"
  ) %>%
  # calculate player distance from ball carrier
  mutate(distance_from_ballCarrier = sqrt((x - ballCarrier_x)^2 + (y - ballCarrier_y)^2)) %>%
  filter(ifelse(playSide == "left", y >= ballCarrier_y, y <= ballCarrier_y)) %>%
  filter(distance_from_ballCarrier <= 5) %>%
  #mutate(edgeSetterId = nflId) %>%
  mutate(
    angle_toballCarrier = abs(atan2(y - ballCarrier_y, x - ballCarrier_x) * (180 / pi)),
    # Calculate and adjust orientation relative to the ball carrier
    relative_o_to_ballCarrier = (((o - (atan2(y - ballCarrier_y, x - ballCarrier_x) *
      (180 / pi))) %% 360) +
      ifelse(playSide == "left", 180, 0)) %% 360
  ) %>%
  select(
    gamePlayId, frameId, playSide, nflId, distance_from_ballCarrier,
    x, y, angle_toballCarrier, s, a, relative_o_to_ballCarrier
  )



wk2_track_data <- full_join(wk2_track_data, edgedefenders %>% select(-c(x,y,s,a, playSide)), by = c("gamePlayId", "frameId", "nflId"))

ballcarrier_edgedefenders <- wk2_track_data %>%
  select(ballCarrierId, colnames(ballcarrier), colnames(edgedefenders), start_frameId, end_frameId) %>%
  filter(frameId >= start_frameId & frameId <= end_frameId) %>%
  select(-start_frameId, -end_frameId) %>%
  mutate(
    # Calculate edge defender's angle relative to ball carrier's ideal path
    angle_toIdealPath = ifelse(playSide == "left",
      (360 - ((angle_toballCarrier - ballCarrier_o) + 360) %% 360),
      ((angle_toballCarrier - ballCarrier_o) + 360) %% 360
    )
  ) %>%
  mutate(
    # Convert orientations to radians
    ballCarrier_o_rad = ballCarrier_o * (pi / 180),
    edgeDef_o_rad = relative_o_to_ballCarrier * (pi / 180),

    # Calculate components of velocity
    ballCarrier_velocity_x = ballCarrier_s * cos(ballCarrier_o_rad),
    ballCarrier_velocity_y = ballCarrier_s * sin(ballCarrier_o_rad),
    edgeDef_velocity_x = s * cos(edgeDef_o_rad),
    edgeDef_velocity_y = s * sin(edgeDef_o_rad),

    # Calculate vector from edge setter to ball carrier
    vector_to_ballCarrier_x = ballCarrier_x - x,
    vector_to_ballCarrier_y = ballCarrier_y - y,

    # Project speed of edge setter towards ball carrier
    edgeDef_speed_towards_ballCarrier = (edgeDef_velocity_x * vector_to_ballCarrier_x +
      edgeDef_velocity_y * vector_to_ballCarrier_y) /
      sqrt(vector_to_ballCarrier_x^2 + vector_to_ballCarrier_y^2),

    # Calculate vector in the direction of ball carrier's movement
    ballCarrier_movement_vector_x = ballCarrier_velocity_x - edgeDef_velocity_x,
    ballCarrier_movement_vector_y = ballCarrier_velocity_y - edgeDef_velocity_y,

    # Normalize the ball carrier's movement vector to create a unit vector
    magnitude_ballCarrier_movement = sqrt(ballCarrier_movement_vector_x^2 + ballCarrier_movement_vector_y^2),
    ballCarrier_movement_unit_x = ballCarrier_movement_vector_x / magnitude_ballCarrier_movement,
    ballCarrier_movement_unit_y = ballCarrier_movement_vector_y / magnitude_ballCarrier_movement,

    # Project edge setter's velocity onto ball carrier's movement direction
    edgeDef_speed_towards_ballCarrierPath = (edgeDef_velocity_x * ballCarrier_movement_unit_x +
      edgeDef_velocity_y * ballCarrier_movement_unit_y)
  ) %>%
  select(
    gamePlayId, frameId, ballCarrierId, 
    nflId,
    distance_from_ballCarrier, relative_o_to_ballCarrier,
    angle_toIdealPath, edgeDef_speed_towards_ballCarrier, edgeDef_speed_towards_ballCarrierPath
  ) %>%
  na.omit()
```

# Create Edge Intensity Rating

```{r}
EIR <- ballcarrier_edgedefenders %>%
  mutate(
    # Scaling variables where lower is better
    scale_dist = 1 - (distance_from_ballCarrier - min(distance_from_ballCarrier, na.rm = TRUE)) / (max(distance_from_ballCarrier, na.rm = TRUE) - min(distance_from_ballCarrier, na.rm = TRUE)),

    # Scaling variables where higher is better
    scale_speed_towards_bc = (edgeDef_speed_towards_ballCarrier - min(edgeDef_speed_towards_ballCarrier, na.rm = TRUE)) / (max(edgeDef_speed_towards_ballCarrier, na.rm = TRUE) - min(edgeDef_speed_towards_ballCarrier, na.rm = TRUE)),
    scale_speed_towards_path = (edgeDef_speed_towards_ballCarrierPath - min(edgeDef_speed_towards_ballCarrierPath, na.rm = TRUE)) / (max(edgeDef_speed_towards_ballCarrierPath, na.rm = TRUE) - min(edgeDef_speed_towards_ballCarrierPath, na.rm = TRUE)),

    # Scaling degrees variables
    scale_o_to_bc = (cos(pi * relative_o_to_ballCarrier / 180) + 1) / 2,  # Normalized to range from 0 to 1
    scale_angle_to_path = (cos(pi * angle_toIdealPath / 180) + 1) / 2,
    
    # Include distance twice so it has doubled the weight
    scale_dist_doubled = scale_dist
  ) %>%
  # Calculate the mean of the scaled values
  reframe(gamePlayId, frameId, nflId,
    edge_intensity_rating = rowMeans(select(., starts_with("scale_")), na.rm = TRUE) * 100
  ) 
```

```{r}
ggplot(EIR,
       aes(x = edge_intensity_rating)) +
  geom_histogram() +
  labs(title = "Distribution of Edge Intensity Rating", x = "Edge Intensity Rating", y = "Count")

```

```{r}
wk2_track_data <- full_join(wk2_track_data, EIR, by = c("gamePlayId", "frameId", "nflId"))

```

```{r}
test_run <- wk2_track_data %>% filter(gameId == 2022091500, playId == 1983)
nfl_field(c(0, 120)) +
  geom_point(
    data = test_run, aes(x = x, y = y, color = club),
    show.legend = FALSE,
    size = 2
  ) +
  geom_point(data = test_run %>% filter(position %in% c("G","T", "C")), aes(x = x, y = y), color = "black", size = 2) +
  #geom_point(data = test_run %>% filter(!is.na(edge_intensity_rating)), aes(x = x, y = y), color = "black") +
  transition_time(frameId) +
  scale_color_manual(values = c("purple", "yellow", "white"))
```

```{r}
wk2_track_data %>% 
  ggplot(aes(x = edge_intensity_rating, y = expectedPointsAdded)) +
  geom_point(alpha = 0.1) +
  geom_smooth() +
  labs(title = "Edge Intensity Rating vs. Angle Difference from 180", x = "Edge Intensity Rating", y = "Angle Difference from 180")
```


# Modeling EIR

```{r}
wk2_track_data %>% filter(!is.na(edge_intensity_rating)) %>%
  select(gamePlayId, frameId, nflId) %>%
  group_by(gamePlayId, frameId) %>%
  summarise(count = n()) %>%
  arrange(desc(count))
```




# Save the data
Saving the data as wk2_triangles.csv

```{r}
# Save dataframe as CSV
write.csv(wk2_track_data, file = "data/wk2_triangles.csv", row.names = FALSE)
```
